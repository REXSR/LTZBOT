const Discord = require('discord.js');
const client = new Discord.Client();
const prefix = "#";
let ar = JSON.parse(fs.readFileSync(`AutoRole.json`, `utf8`))
const fs = require('fs')


client.on('ready', () => {

    console.log(`Logged in as ${client.user.tag}!`);

    console.log(`in ${client.guilds.size} servers `)

    console.log(`[NAWAF] ${client.users.size}`)

    client.user.setStatus("online")   

});
   



var fkk =[
        {f:"ŸÅŸÉŸÉ ÿ®ÿ≥ŸÖ ÿßŸÑŸÑŸá ÿßŸÑÿ±ÿ≠ŸÖŸÜ ÿßŸÑÿ±ÿ≠ŸäŸÖ",k:"ÿ® ÿ≥ ŸÖ ÿß ŸÑ ŸÑ Ÿá ÿß ŸÑ ÿ± ÿ≠ ŸÖ ŸÜ ÿß ŸÑ ÿ± ÿ≠ Ÿä ŸÖ"},
        {f:"ŸÅŸÉŸÉ ÿ®ÿßÿµ",k:"ÿ® ÿß ÿµ"},
        {f:"ŸÅŸÉŸÉ ÿπÿ±ÿ®ÿ© ",k:"ÿπ ÿ± ÿ® ÿ©"},
        {f:"ŸÅŸÉŸÉ ÿ≥Ÿäÿßÿ±ÿ©",k:"ÿ≥ Ÿä ÿß ÿ± ÿ©"},
        {f:"ŸÅŸÉŸÉ ÿ≥Ÿäÿ±ŸÅÿ±ŸÜÿß ÿßÿ≠ŸÑŸâ ÿ≥Ÿäÿ±ŸÅÿ±",k:"ÿ≥ Ÿä ÿ± ŸÅ ÿ± ŸÜ ÿß ÿß ÿ≠ ŸÑ Ÿâ ÿ≥ Ÿä ÿ± ŸÅ ÿ±"},
        {f:"ŸÅŸÉŸÉ ÿßŸÑÿπŸÜŸàÿØ ",k:"ÿß ŸÑ ÿπ ŸÜ Ÿà ÿØ"},
        {f:"ŸÅŸÉŸÉ ÿßŸÑŸÖÿ≥ÿ™ÿ™ŸÉÿπŸÉÿ®ÿ™ŸäŸá",k:"ÿß ŸÑ ŸÖ ÿ≥ ÿ™ ÿ™ ŸÉ ÿπ ŸÉ ÿ® ÿ™ Ÿä Ÿá"},
        {f:"ŸÅŸÉŸÉ ŸÜŸàÿßŸÅ",k:"ŸÜ Ÿà ÿß ŸÅ"},
        {f:"ŸÅŸÉŸÉ ÿßŸàŸÜÿ±ŸÜÿß ÿßÿ≠ŸÑŸâ ÿßŸàŸÜÿ±",k:"ÿß Ÿà ŸÜ ÿ± ŸÜ ÿß ÿß ÿ≠ ŸÑ Ÿâ ÿß Ÿà ŸÜ ÿ±"},
        {f:"ŸÅŸÉŸÉ ÿßŸÑÿ≠Ÿäÿßÿ© ÿ≠ŸÑŸàÿ©",k:"ÿß ŸÑ ÿ≠ Ÿä ÿß ÿ© ÿ≠ ŸÑ Ÿà ÿ©"},
        {f:"ŸÅŸÉŸÉ ŸÉÿßÿ≤ÿÆÿ≥ÿ™ÿßŸÜ ",k:"ŸÉ ÿß ÿ≤ ÿÆ ÿ≥ ÿ™ ÿß ŸÜ"},
        {f:"ŸÑÿ≠ŸÖ ÿßŸÑÿ≠ŸÖÿßŸÖ ÿ≠ŸÑÿßŸÑ ŸàŸÑÿ≠ŸÖ ÿßŸÑÿ≠ŸÖÿßÿ± ÿ≠ÿ±ÿßŸÖ ",k:"ŸÑ ÿ≠ ŸÖ ÿß ŸÑ ÿ≠ ŸÖ ÿß ŸÖ ÿ≠ ŸÑ ÿß ŸÑ Ÿà ŸÑ ÿ≠ ŸÖ ÿß ŸÑ ÿ≠ ŸÖ ÿß ÿ± ÿ≠ ÿ± ÿß ŸÖ"},
        {f:"ŸÅŸÉŸÉ ÿßÿ≥ÿ™ŸàŸÜŸäÿß ",k:"ÿß ÿ≥ ÿ™ Ÿà ŸÜ Ÿä ÿß"},
        {f:"ŸÅŸÉŸÉ ŸÑŸÇŸÖÿ© Ÿàÿ¨ÿ∫ŸÖŸá ",k:"ŸÑ ŸÇ ŸÖ ÿ© Ÿà ÿ¨ ÿ∫ ŸÖ Ÿá"},
        {f:"ŸÅŸÉŸÉ ÿ≤ŸÜÿØŸäŸÇ  ",k:"ÿ≤ ŸÜ ÿØ Ÿä ŸÇ"},
        {f:"ŸÅŸÉŸÉ ÿßÿ≥ÿ™ÿ±ÿßŸÑŸäÿß ",k:"ÿß ÿ≥ ÿ™ ÿ± ÿß ŸÑ Ÿä ÿß"},
        {f:"ŸÅŸÉŸÉ ÿ≥Ÿàÿ±Ÿäÿß ",k:"ÿ≥ Ÿà ÿ± Ÿä ÿß"},
        {f:"ŸÅŸÉŸÉ ÿßŸÑÿßÿ±ÿØŸÜ ",k:"ÿß ŸÑ ÿß ÿ± ÿØ ŸÜ"},
        {f:"ŸÅŸÉŸÉ ÿ∑ŸÖÿßÿ∑ŸÖ ",k:"ÿ∑ ŸÖ ÿß ÿ∑ ŸÖ"},
        {f:"ŸÅŸÉŸÉ ÿ≥ÿßÿ±ÿ© ",k:"ÿ≥ ÿß ÿ± ÿ©"},
        {f:"ŸÅŸÉŸÉ ÿØÿ±ÿßÿ¨ŸàŸÜ ",k:"ÿØ ÿ± ÿß ÿ¨ Ÿà ŸÜ"},
        {f:"ŸÅŸÉŸÉ ÿ≥Ÿäÿ±ŸÅÿ± ",k:"ÿ≥ Ÿä ÿ± ŸÅ ÿ±"},
        {n:"ŸÅŸÉŸÉ ÿßŸÑÿ¨ÿ®ŸÑ",m:"ÿß ŸÑ ÿ¨ ÿ® ŸÑ"},
        {n:"ŸÅŸÉŸÉ Ÿáÿ∂ÿ®ÿ©",m:"Ÿá ÿ∂ ÿ® ÿ©"},
        {n:"ŸÅŸÉŸÉ ÿÆŸàÿßÿ∑ÿ±",m:"ÿÆ Ÿà ÿß ÿ∑ ÿ±"},
        {n:"ŸÅŸÉŸÉ ÿßÿ±ÿ≠ÿ®Ÿà",m:"ÿß ÿ± ÿ≠ ÿ® Ÿà"},
        {n:"ŸÅŸÉŸÉ ÿßÿ∑ŸÜÿÆ ÿ≥Ÿäÿ±ŸÅÿ±",m:"ÿß ÿ∑ ŸÜ ÿÆ ÿ≥ Ÿä ŸÅ ÿ±"},
        {n:"ŸÅŸÉŸÉ ÿßÿ≠ÿ®ŸÉ",m:"ÿß ÿ≠ ÿ® ŸÉ"},
        {n:"ŸÅŸÉŸÉ ÿ≥ÿ®ÿ±ÿßŸäÿ≤",m:"ÿ≥ ÿ® ÿ± ÿß Ÿä ÿ≤"},
        {n:"ŸÅŸÉŸÉ ŸàŸÑŸä ÿπŸÑŸâ ÿ£ŸÖÿ™ŸÉ",m:"Ÿà ŸÑ Ÿä ÿπ ŸÑ Ÿâ ÿ£ ŸÖ ÿ™ ŸÉ"},
        {n:"ŸÅŸÉŸÉ ÿßŸÑŸà ŸÖÿ≠ÿØ",m:"ÿß ŸÑ Ÿà ŸÖ ÿ≠ ŸÖ ÿØ"},


   ];






client.on("message", async message => {
       var prefix = "-";
    if(message.content == prefix+"ŸÅŸÉŸÉ"){
        if(UserBlocked.has(message.guild.id)) return message.channel.send("ŸáŸÜÿßŸÉ ÿ¨ŸÑÿ≥ÿ© .")
        UserBlocked.add(message.guild.id)
        var ask = fkk[Math.floor(Math.random() * fkk.length)];
        let embed = new Discord.RichEmbed()
        .setTitle('ŸÑÿπÿ®ÿ© ŸÅŸÉŸÉ')
        .setAuthor(message.author.username, message.author.avatarURL)
        .setColor("RANDOM")
        .setDescription(ask.f);
        message.channel.sendEmbed(embed).then(msg=> msg.delete(200000))
        const msgs = await message.channel.awaitMessages(msg => msg.author.id !== client.user.id ,{maxMatches:1,time:100000});
            UserBlocked.delete(message.guild.id)
        msgs.forEach(result => {
           if(result.author.id == client.user.id) return;
           if(result.content == "fkk") return
           if(result.content == ask.k){

             let embeds = new Discord.RichEmbed()
             .setTitle(':white_check_mark: ÿßÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©')
             .setAuthor(message.author.username, message.author.avatarURL)
             .setColor("RANDOM")
             .setDescription(`**${result.author.username}** ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©`);
                message.channel.sendEmbed(embeds);                return;
           } else {

                               var embedx = new Discord.RichEmbed()
             .setTitle(':x:ÿÆÿ∑ÿßÿ°')
             .setAuthor(message.author.username, message.author.avatarURL)
             .setColor("RANDOM")
             .setDescription(`**${result.author.username}** ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ∑ÿ¶ÿ©`);

                message.channel.sendEmbed(embedx);
           }
     });
  }
});


client.on('guildMemberAdd', member => {
  if(!ar[member.guild.id]) ar[member.guild.id] = {
  onoff: 'Off',
  role: 'Member'
  }
  if(ar[member.guild.id].onoff === 'Off') return;
member.addRole(member.guild.roles.find(`name`, ar[member.guild.id].role)).catch(console.error)
})

client.on('message', message => { 
  var sender = message.author

if(!message.guild) return
  if(!ar[message.guild.id]) ar[message.guild.id] = {
  onoff: 'Off',
  role: 'Member'
  }

if(message.content.startsWith(`autorole`)) {
         
  let perms = message.member.hasPermission(`MANAGE_ROLES`)

  if(!perms) return message.reply(`You don't have permissions, required permission : Manage Roles.`)
  let args = message.content.split(" ").slice(1)
  if(!args.join(" ")) return message.reply(`${prefix}autorole toggle / set [ROLE NAME]`)
  let state = args[0]
  if(!state.trim().toLowerCase() == 'toggle' || !state.trim().toLowerCase() == 'setrole') return message.reply(`Please type a right state, ${prefix}modlogs toggle/setrole [ROLE NAME]`) 
    if(state.trim().toLowerCase() == 'toggle') { 
     if(ar[message.guild.id].onoff === 'Off') return [message.channel.send(`**The Autorole Is __ùêéùêç__ !**`), ar[message.guild.id].onoff = 'On']
     if(ar[message.guild.id].onoff === 'On') return [message.channel.send(`**The Autorole Is __ùêéùêÖùêÖ__ !**`), ar[message.guild.id].onoff = 'Off']
    }
   if(state.trim().toLowerCase() == 'set') {
   let newRole = message.content.split(" ").slice(2).join(" ")
   if(!newRole) return message.reply(`${prefix}autorole set [ROLE NAME]`)
     if(!message.guild.roles.find(`name`,newRole)) return message.reply(`I Cant Find This Role.`)
    ar[message.guild.id].role = newRole
     message.channel.send(`**The AutoRole Has Been Changed to ${newRole}.**`)
   } 
         }
if(message.content === 'info') {
    let perms = message.member.hasPermission(`MANAGE_GUILD`) 
    if(!perms) return message.reply(`You don't have permissions.`)
    var embed = new Discord.RichEmbed()

.addField(`Autorole : :sparkles:  `, `
State : __${ar[message.guild.id].onoff}__
Role : __${ar[message.guild.id].role}__`)


    .setColor(`BLUE`)
    message.channel.send({embed})
  }


    fs.writeFile("./AutoRole.json", JSON.stringify(ar), (err) => {
    if (err) console.error(err)
  });


});


client.on('message', async message => {
    if(message.author.bot) return;
    if(message.channel.type === 'dm') return;
 
    var prefix = '#'; //<==== ÿ™ŸÇÿØÿ± ÿ™ÿ∫Ÿäÿ± ÿßŸÑÿ®ÿ±ŸÅŸÉÿ≥
    var args = message.content.toLowerCase().split(' ');
    var command = args[0];
    var userM = message.guild.member(message.mentions.users.first() || message.guild.members.find(m => m.id === args[1]));
 
    if(command == prefix + 'role') {
        if(!message.member.hasPermission('MANAGE_ROLES')) return message.channel.send(':no_entry: | You dont have **MANAGE_ROLES** Permission!');
        if(!message.guild.member(client.user).hasPermission('MANAGE_ROLES')) return message.channel.send(':no_entry: | I dont have **MANAGE_ROLES** Permission!');
        if(!message.guild.member(client.user).hasPermission('EMBED_LINKS')) return message.channel.send(':no_entry: | I dont have **EMBED_LINKS** Permission!');
 
        let roleCommand = new Discord.RichEmbed() // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
        .setTitle(':white_check_mark: Role Command.')
        .setColor('GREEN')
        .setDescription(`**\n${prefix}role <SOMEONE> <ROLE>**\n‚û• \`\`For give or delete from some one the role.\`\`\n\n**${prefix}role humans add <ROLE>**\n‚û• \`\`For give the humans role.\`\`\n\n**${prefix}role humans remove <ROLE>**\n‚û• \`\`For delete from the humans role.\`\`\n\n**${prefix}role bots add <ROLE>**\n‚û• \`\`For give the bots role.\`\`\n\n**${prefix}role bots remove <ROLE>**\n‚û• \`\`For delete from the bots role.\`\`\n\n**${prefix}role all add <ROLE>**\n‚û• \`\`For give all role.\`\`\n\n**${prefix}role all remove <ROLE>**\n‚û• \`\`For remove from all role.\`\``)
        .setTimestamp()
        .setFooter(message.author.tag, message.author.avatarURL)
 
        if(!args[1]) return message.channel.send(roleCommand);
        if(!userM && args[1] !== 'humans' && args[1] !== 'bots' && args[1] !== 'all') return message.channel.send(roleCommand);
 
        if(userM) {
            var argsRole = args[2];
        }else if(!userM && args[1] === 'humans' || args[1] === 'bots' || args[1] === 'all') {
            var argsRole = args[3];
        }
 
        var getRole = message.mentions.roles.first() || message.guild.roles.find(r => r.id === argsRole) || message.guild.roles.find(r => r.name.toLowerCase().includes(argsRole));
 
        if(userM) {
            if(!args[2]) return message.channel.send(`**Useage:** ${prefix}role <USER> \`\`<ROLE>\`\``);
            if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
            if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');
            if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Or \`\`DELETE\`\` From any user have or not have **${getRole.name}** role beacuse this role highest from my role!`);
 
          if(message.guild.member(userM.user).roles.has(getRole.id)) {
              message.guild.member(userM.user).removeRole(getRole.id);
              message.channel.send(`:white_check_mark: | Successfully \`\`DELETE\`\` The role **${getRole.name}** From user **${userM.user.tag}**`);
          }else if(!message.guild.member(userM.user).roles.has(getRole.id)) {
              message.guild.member(userM.user).addRole(getRole.id);
              message.channel.send(`:white_check_mark: | Successfully \`\`GIVE\`\` The role **${getRole.name}** To user **${userM.user.tag}**`);
          }
      }else if(args[1] === 'humans') {
          let notArgs = new Discord.RichEmbed()
          .setTitle(':white_check_mark: Role Command.') // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
          .setColor('GREEN')
          .setDescription(`**\n${prefix}role humans add <ROLE>**\n‚û• \`\`For give the humans the role.\`\`\n\n**${prefix}role humans remove <ROLE>**\n‚û• \`\`For delete the role from all humans.\`\``)
          .setTimestamp()
          .setFooter(message.author.tag, message.author.avatarURL)
 
          if(!args[2]) return message.channel.send(notArgs);
          if(!args[3]) return message.channel.send(notArgs);
          if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
            if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');
 
            if(args[2] === 'add') {
                if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Any User the role with name **${getRole.name}** beacuse the role highest then my role!`);
              if(message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user not have **${getRole.name}** role!`);
 
              let humansSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans the role **${getRole.name}**`)
              .setColor('RED')
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\n‚úÖ = Sure, give him the role.\n\n‚ùé = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(humansSure).then(msg => {
                  msg.react('‚úÖ').then(() => msg.react('‚ùé'))
 
                  let giveHim = (reaction, user) => reaction.emoji.name === '‚úÖ'  && user.id === message.author.id;
                  let dontGiveHim = (reaction, user) => reaction.emoji.name === '‚ùé' && user.id === message.author.id;
                  let give = msg.createReactionCollector(giveHim, { time: 60000 });
                  let dontGive = msg.createReactionCollector(dontGiveHim, { time: 60000 });
 
                  give.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans the role **${getRole.name}** ...`).then(message1 => {
                          message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).forEach(async m => {
                              message.guild.member(m).addRole(getRole.id) // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully give all **Humans** The role **${getRole.name}** .`);
                          });
                      });
                  });
                  dontGive.on('collect', r => {
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  });
              })
          }else if(args[2] === 'remove') {
              if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`REMOVE\`\` The role with name **${getRole.name}** From any User beacuse the role highest then my role!`);
              if(message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user have **${getRole.name}** role!`);
 
              let humansSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to remove **${getRole.name}** from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans?`)
              .setColor('RED') // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\n‚úÖ = Sure, remove the role from him.\n\n‚ùé = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(humansSure).then(msg => {
                  msg.react('‚úÖ').then(() => msg.react('‚ùé'))
 
                  let removeRole = (reaction, user) => reaction.emoji.name === '‚úÖ'  && user.id === message.author.id;
                  let dontRemoveRole = (reaction, user) => reaction.emoji.name === '‚ùé' && user.id === message.author.id;
                  let remove = msg.createReactionCollector(removeRole, { time: 60000 });
                  let dontRemove = msg.createReactionCollector(dontRemoveRole, { time: 60000 });
 
                  remove.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to delete from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans the role **${getRole.name}** ...`).then(message1 => {
                          message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).forEach(async m => {
                              message.guild.member(m).removeRole(getRole.id)
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully remove the role **${getRole.name}** From all **Humans** .`);
                          });
                      }); // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
                  });
                  dontRemove.on('collect', r => {
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  });
              })
          }
      }else if(args[1] === 'bots') {
      let notArgs = new Discord.RichEmbed()
          .setTitle(':white_check_mark: Role Command.')
          .setColor('GREEN')
          .setDescription(`**\n${prefix}role bots add <ROLE>**\n‚û• \`\`For give the bots the role.\`\`\n\n**${prefix}role bots remove <ROLE>**\n‚û• \`\`For delete the role from all bots.\`\``)
          .setTimestamp()
          .setFooter(message.author.tag, message.author.avatarURL)
 
          if(!args[2]) return message.channel.send(notArgs);
          if(!args[3]) return message.channel.send(notArgs); // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
          if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
            if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');
 
            if(args[2] === 'add') {
                if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Any Bot the role with name **${getRole.name}** beacuse the role highest then my role!`);
              if(message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any bot not have **${getRole.name}** role!`);
 
              let botsSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to give **${message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).size}** Bots the role **${getRole.name}**`)
              .setColor('RED')
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\n‚úÖ = Sure, give him the role.\n\n‚ùé = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(botsSure).then(msg => {
                  msg.react('‚úÖ').then(() => msg.react('‚ùé'))
 
                  let giveHim = (reaction, user) => reaction.emoji.name === '‚úÖ'  && user.id === message.author.id;
                  let dontGiveHim = (reaction, user) => reaction.emoji.name === '‚ùé' && user.id === message.author.id;
                  let give = msg.createReactionCollector(giveHim, { time: 60000 });
                  let dontGive = msg.createReactionCollector(dontGiveHim, { time: 60000 }); // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
 
                  give.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to give **${message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).size}** Bots the role **${getRole.name}**...`).then(message1 => {
                          message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).forEach(async b => {
                              message.guild.member(b).addRole(getRole.id)
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully give all **Bots** The role **${getRole.name}** .`);
                          });
                      });
                  });
                  dontGive.on('collect', r => {
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  }); // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
              })
          }else if(args[2] === 'remove') {
              if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`REMOVE\`\` The role with name **${getRole.name}** From any Bot beacuse the role highest then my role!`);
              if(message.guild.members.filter(b => message.guild.member(b).roles.has(getRole.id) && b.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any bot have **${getRole.name}** role!`);
 
              let humansSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to remove **${getRole.name}** from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && m.user.bot).size}** Bots?`)
              .setColor('RED')
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\n‚úÖ = Sure, remove the role from him.\n\n‚ùé = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(humansSure).then(msg => {
                  msg.react('‚úÖ').then(() => msg.react('‚ùé')) // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
 
                  let removeRole = (reaction, user) => reaction.emoji.name === '‚úÖ'  && user.id === message.author.id;
                  let dontRemoveRole = (reaction, user) => reaction.emoji.name === '‚ùé' && user.id === message.author.id;
                  let remove = msg.createReactionCollector(removeRole, { time: 60000 });
                  let dontRemove = msg.createReactionCollector(dontRemoveRole, { time: 60000 });
 
                  remove.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to delete from **${message.guild.members.filter(b => message.guild.member(b).roles.has(getRole.id) && b.user.bot).size}** Bots the role **${getRole.name}**...`).then(message1 => {
                          message.guild.members.filter(b => message.guild.member(b).roles.has(getRole.id) && b.user.bot).forEach(async b => {
                              message.guild.member(b).removeRole(getRole.id)
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully remove the role **${getRole.name}** From all **Bots** .`);
                          });
                      });
                  });
                  dontRemove.on('collect', r => { // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  });
              })
          }
      }else if(args[1] === 'all') {
          let notArgs = new Discord.RichEmbed()
          .setTitle(':white_check_mark: Role Command.')
          .setColor('GREEN') // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
          .setDescription(`**\n${prefix}role all add <ROLE>**\n‚û• \`\`For give all the role.\`\`\n\n**${prefix}role all remove <ROLE>**\n‚û• \`\`For delete the role from all.\`\``)
          .setTimestamp()
          .setFooter(message.author.tag, message.author.avatarURL)
 
          if(!args[2]) return message.channel.send(notArgs);
          if(!args[3]) return message.channel.send(notArgs);
          if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
            if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');
 
            if(args[2] === 'add') {
                if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Any User the role with name **${getRole.name}** beacuse the role highest then my role!`);
              if(message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user not have **${getRole.name}** role!`);
 
              let allSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).size}** The role **${getRole.name}** ?`)
              .setColor('RED')
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\n‚úÖ = Sure, give all the role.\n\n‚ùé = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(allSure).then(msg => {
                  msg.react('‚úÖ').then(() => msg.react('‚ùé'))
 
                  let giveAll = (reaction, user) => reaction.emoji.name === '‚úÖ'  && user.id === message.author.id;
                  let dontGiveAll = (reaction, user) => reaction.emoji.name === '‚ùé' && user.id === message.author.id;
                  let give = msg.createReactionCollector(giveAll, { time: 60000 });
                  let dontGive = msg.createReactionCollector(dontGiveAll, { time: 60000 });
// ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
                  give.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).size}** The role **${getRole.name}** ...`).then(message1 => {
                          message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).forEach(async m => {
                              message.guild.member(m).addRole(getRole.id)
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully give **All** The role **${getRole.name}** .`);
                          });
                      });
                  });
                  dontGive.on('collect', r => {
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  });
              })
          }else if(args[2] === 'remove') {
              if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`REMOVE\`\` The role with name **${getRole.name}** From any User beacuse the role highest then my role!`);
              if(message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user have **${getRole.name}** role!`);
 
              let allSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to remove **${getRole.name}** from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).size}** ?`)
              .setColor('RED')
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\n‚úÖ = Sure, remove the role from him.\n\n‚ùé = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(allSure).then(msg => {
                  msg.react('‚úÖ').then(() => msg.react('‚ùé')) // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
 
                  let removeRole = (reaction, user) => reaction.emoji.name === '‚úÖ'  && user.id === message.author.id;
                  let dontRemoveRole = (reaction, user) => reaction.emoji.name === '‚ùé' && user.id === message.author.id;
                  let remove = msg.createReactionCollector(removeRole, { time: 60000 });
                  let dontRemove = msg.createReactionCollector(dontRemoveRole, { time: 60000 });
 
                  remove.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to delete from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).size}** The role **${getRole.name}** ...`).then(message1 => {
                          message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).forEach(async m => {
                              message.guild.member(m).removeRole(getRole.id);
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully remove the role **${getRole.name}** From **All** .`);
                          });
                      }); // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
                  });
                  dontRemove.on('collect', r => {
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  });
              })
          } // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
      }
  } // ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤
});














    

        








       

        
        
        
        
        




client.login(process.env.BOT_TOKEN);
